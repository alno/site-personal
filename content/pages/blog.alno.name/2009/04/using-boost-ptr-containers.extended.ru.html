<h2>Использование</h2>

<p>В примере мы будем использовать ptr_vector. Для него необходимо подключить один заголовочный файл:</p>

<r:code lang="cpp">
#include <boost/ptr_container/ptr_vector.hpp>
</r:code>

<p>Рассмотрим простейший пример использования, приведенный в документации библиотеки. Предположим, что у нас имеется классическая иерархия классов:</p>

<r:code lang="cpp">
class animal
{
public:
    virtual      ~animal()   {}
    virtual void eat()       = 0;
    virtual int  age() const = 0;
    // ...
};

class mammal : public animal
{
    // ...
};

class bird : public animal
{
    // ...
};
</r:code>

<p>Теперь, нам необходимо создать список животных. Для этого мы будем использовать контейнер <b>ptr_vector</b>:</p>

<r:code lang="cpp">
boost::ptr_vector<animal> the_animals;
</r:code>

<p>Сразу обращаем внимание: при объявлении контейнера * не указывается. Чтобы добавить объект в контейнер, вызываем метод push_back, аналогично стандартному контейнеру <b>std::vector</b>:</p>

<r:code lang="cpp">
the_animals.push_back( new mammal("joe") );
the_animals.push_back( new bird("dodo") );
</r:code>

<p>Теперь о доступе к элементам: <b>контейнер предоставляет доступ к элементам не по указателям, а по ссылкам</b>. То, есть необходимо писать следующим образом:</p>

<r:code lang="cpp">
the_animals[0].eat(); // А в случае std::vector<animal*> это было бы vec[0]->eat();

boost::ptr_vector<animal>::iterator  i = vec.begin();
i->eat(); // Опять же, для std::vector это было бы (*i)->eat(); Не знаю как Вас, но меня такая запись всегда раздражала.
</r:code>

<p>Еще одно отличие: обработка нулевых указателей. Стандартный <b>vector</b> позволяет добавлять элементы - нулевые указатели. <b>ptr_vector</b> - не позволяет (по умолчанию). То есть, следующий код вызывает исключение:</p>

<r:code lang="cpp">
the_animals.insert( the_animals.begin(), 0 ); // Исключение
</r:code>

<p>Однако, если Вам необходимо, Вы можете разрешить хранение нулевых указателей. Делается это следующим образом:</p>

<r:code lang="cpp">
boost::ptr_vector< boost::nullable<animal> > the_animals_nullable;

the_animals_nullable.insert( the_animals_nullable.begin(), 0 ); // Это уже корректно
</r:code>

<h2>Клонирование и перемещение данных</h2>

<p>Крайне важное отличие таких контейнеров от стандартных в том, что они не могут быть скопированы напрямую! В чем причина: предполагается, что каждый указатель в любой момент времени находится в одном из таких контейнеров, который и освободит память при необходимости. Если же скопировать содержимое, то Вы получили бы указатель в двух контейнерах, что привело бы к последующим проблемам с их удалением.</p>

<p>Однако, не все так плохо. Вместо копирования можно осуществлять другие операции:</p>

<ul>
  <li>Во-первых, контейнеры можно клонировать, вызывая клонирование всех входящих в них элементов.</li>
  <li>Во-вторых, данные можно извлечь из контейнера. И затем, например, переместить в другой.</li>
</ul>

<p>Сначала о клонировании. Для того, чтобы содержимео контейнера могло быть клонировано, для всех его элементов должны быть определены две функции:</p>

<r:code lang="cpp">
namespace boost
{
    inline T* new_clone( const T& t )
    {
        // Здесь клонируем объект...
    }

    void delete_clone( const T* t )
    {
        // Здесь удаляем объект...
    }
}
</r:code>

<p>Если Ваш компилятор поддерживает Argument-Dependent Lookup, то их можно объявлять не в пространстве имен boost, а в том, где расположен обрабатываемый ими тип.</p>

<p>После того, как такие функции объявлены, можно вызывать метод <tt>clone</tt> контейнера:</p>

<r:code lang="cpp">
the_animal_clones = the_animals.clone();
</r:code>

<p>Теперь об извлечении и перемещении. Контейнеры предоставляют набор методов, позволяющих извлечь указатель по итератору и переместить набор элементов в другой контейнер:</p>

<r:code lang="cpp">
boost::ptr_vector<animal>::auto_type the_animal = the_animals.release( the_animals.begin() ); // Извлекаем первый элемент
the_animal->eat();
</r:code>

<p>При этом <tt>auto_type</tt> представляет из себя аналог <tt>std::auto_ptr</tt>.</p>

<p>Для перемещения  существуют два вариант метода <tt>transfer</tt></p>

<r:code lang="cpp">
another_zoo.transfer( another_zoo.end(), // Добавляем последним элементом
                      zoo.begin(),       // Первый элемент
                      zoo );             // Из этого контейнера

another_zoo.transfer( another_zoo.begin(), // Добавляем в конец
                      zoo.begin(),       // От первого
                      zoo.end(),         // До последнего
                      zoo );             // Из этого контейнера

</r:code>

<h2>Алгоритмы</h2>

<p>К сожалению, с этими контейнерами нельзя использовать стандартные алгоритмы STL. Однако, некоторые основные реализованы в виде методов:</p>

<r:code lang="cpp">
boost::ptr_vector<animal> zoo;
...
zoo.sort();                               // Предполагаем, что описан 'bool operator<( const animal&, const animal& )'
zoo.sort( std::less<animal>() );          // То же самое, обращаем внимание на отсутствие *
zoo.sort( zoo.begin(), zoo.begin() + 5 ); // Сортируем участок

zoo.unique();                             // Предполагаем, что описан 'bool operator==( const animal&, const animal& )'
zoo.unique( zoo.begin(), zoo.begin() + 5, my_comparison_predicate() ); 

zoo.erase_if( my_predicate() );
</r:code>