<h2>Как это использовать?</h2>
Суть конструкции проще объяснить на примере. Допустим, мы объявляем метод eval, который должен принимать произвольное число аргументов произвольного типа.

Как обычно решается такая задача?
<r:code class="java">void eval( Object[] args ) { ... }</r:code>
Но, для того, чтобы вызвать этот метод, приходится оборачивать аргументы в массив:
<r:code class="java">eval( new Object[]{ 1, 2, 3 } );</r:code>
Теперь посмотрим, как это будет выглядеть с конструкцией "...":
<r:code class="java">void eval( Object ... args ) { ... }</r:code>
И вызовы метода:
<r:code class="java">eval( 1, 2, 3 );
eval( 2, "Hello world!!!" );</r:code>
А как изменится при этом тело метода eval? А никак. Внутри метода args по-прежнему является массивом.
<h2>Как это работает?</h2>
Компилятор, встретив такое объявление метода генерирует байт-код точно так же, как если бы это был простой массив. А при вызове, автоматически вставляет байт-код, который формирует этот массив и передает его в метод. Вот и все.
<h2>Где это используется?</h2>
Я это нашел в стандартной библиотеке Java. Первым методом, на который я обратил внимание был <a href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html#addAll(java.util.Collection,%20T...)">Collections.addAll</a>, позволяющий добавлять в коллекцию массив, или произвольное число элементов, заданых отдельно.

Затем уже я обнаружил метод <a href="http://java.sun.com/javase/6/docs/api/java/io/PrintStream.html#printf(java.lang.String%2C%20java.lang.Object...)">PrintStream.printf</a>, позволяющий осуществлять форматированный вывод, как в С++.