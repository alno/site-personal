<h2>scoped_ptr и scoped_array</h2>

<p><b>scoped_ptr</b> хранит указатель на объект в памяти. Объект, на который ссылается указатель автоматически удаляется в случае уничтожения указателя или вызова метода <b>reset()</b>.

Пример объявления и использования такого указателя:
<r:code>
#include <boost/scoped_ptr.hpp> // Заголовочный файл, необходимый для работы

...

{ // Открываем новый блок
	boost::scoped_ptr<MyObject> spobj( new MyObject() ); // Создаем новый объект, и указатель ссылающийся на него

	spobj->myField ++; // Доступ к полю объекта
	spobj->myMethod(); // Вызов метода объекта
	
	MyObject & robj = *spobj; // Получаем ссылку на хранимый объект
	MyObject * pobj = spobj.get(); // Получаем указатель на хранимый объект
	
	if ( spobj ) { // Проверяем, что указатель ссылается на объект
		std::cout << "Указатель ссылается на объект по адресу " << spobj.get() << std::endl;
	}
} // А по завершению блока, переменная spobj уничтожается и автоматически удаляет созданный объект
</r:code>

Чем такой код лучше, чем использование обычного указателя на <i>MyObject</i>? Предположим, что метод <i>myMethod()</i> выкидывает исключение. Что происходит в этом случае, если мы используем обычный указатель? Управление уходит из блока и память остается занятой. В приведенном же выше коде память корректно освобождается, с вызовом деструктора объекта MyObject.</p>

<p><b>scoped_array</b> полностью аналогичен <b>scoped_ptr</b>, c той лишь разницей, что работает с массивами. Аналогичный пример:
<r:code class="cpp">
#include <boost/scoped_array.hpp>

...

{
	int size = ... // Размер массива
	boost::scoped_array&lt;MyObject&gt; sobjects( new MyObject[ size ] ); // Выделяем память под массив и создаем указатель

	sobjects[0].myField++; // Доступ к элементу массива
	sobjects[0].myMethod();

	if ( spobjects ) { // Проверяем, что указатель ссылается на массив
		std::cout << "Указатель ссылается на массив по адресу " << spobjects.get() << std::endl; // Распечатываем адрес массива
	}	
} // А здесь память освобождается
</r:code></p>

<h2>shared_ptr и shared_array</h2>

<p><b>shared_ptr</b> так же хранит указатель на объект в памяти. Отличие от <b>scoped_ptr</b> состоит в том, что shared_ptr добавляет к объекту счетчик ссылок, каждое копирование указателя увеличивает счетчик ссылок, а уничтожение уменьшает. Объект удаляется только тогда, когда значение счетчика ссылок достигает 0.

Пример использования:
<r:code class="cpp">
#include <boost/shared_ptr.hpp>

...

boost::shared_ptr<MyObject> spobj1; // Создаем неинициализированный указатель

{
	boost::shared_ptr<MyObject> spobj2( new MyObject() ); // Создаем новый объект и указатель на него

	spobj2->myField ++; // Доступ к полю объекта
	spobj2->myMethod(); // Вызов метода объекта
	
	MyObject & robj = *spobj2; // Получаем ссылку на хранимый объект
	MyObject * pobj = spobj2.get(); // Получаем указатель на хранимый объект

	if ( spobj2 ) { // Проверяем, что указатель ссылается на объект
		std::cout << "Указатель ссылается на объект по адресу " << spobj2.get() << std::endl;
	}

	spobj1 = spobj2; // Копируем указатель
} // Здесь уничтожается spobj2, но объект не удаляется, потому что на него еще ссылается spobj1

spobj1->myMethod(); // Еще раз вызываем метод того же объекта

spobj1.reset(); // Здесь указатель spobj1 сбрасывается, и объект удаляется, потому что никаких указателей на него уже не ссылается
	
</r:code></p>

<p><b>shared_array</b> полностью аналогичен shared_ptr, только работает с массивами. Пример кода приводиться не будет, там и так все понятно, если посмотреть на <i>shared_ptr</i> и <i>scoped_array</i>.</p>

<h2>Ошибки при использовании shared_ptr</h2>

<p>Здесь я опишу некоторые ошибки которые можно допустить при работе с разделяемыми указателями.</p>

<h3>Создание нескольких указателей на один объект без копирования</h3>
<p>Пожалуй, самая распространенная ошибка. Рассмотрим следующий код:

<r:code class="cpp">

MyObject pobj = new MyObject(); // Создаем новый объект

{ // Начинаем новый блок
	boost::shared_ptr<MyObject> sp1( pobj ); // Создаем разделяемый указатель на объект

	...

	boost::shared_ptr<MyObject> sp2( pobj ); //Создаем второй разделыяемый указатель на объект

	...
} // И вот здесь наша программа падает
</r:code>

Почему же программа должна упасть в конце блока? Создание двух таких указателей приводит к созданию двух счетчиков ссылок!! И каждый из них обнуляется в конце блока, что приводит к двум попыткам удаления объекта. Первая срабатывает, а вот вторая валит программу.</p>

<p>Простейший способ избежать таких ошибок, то стараться не создавать разделяемые указатели на объекты из указателей другого вида, а сразу использовать разделяемый указатель на объект сразу после его создания. Т.е предыдущий код стоит оформить следующим образом:

<r:code class="cpp">boost::shared_ptr<MyObject> pobj( new MyObject() ); // Создаем новый объект и сразу же разделяемый указатель на него

{ // Начинаем новый блок
	boost::shared_ptr<MyObject> sp1 = pobj; // Создаем разделяемый указатель на объект

	...

	boost::shared_ptr<MyObject> sp2 = pobj; //Создаем второй разделыяемый указатель на объект

	...

	pobj.reset(); // Освобождаем исходный указатель
} // Здесь объект корректно удаляется
</r:code></p>

<h3>Создание анонимных указателей как аргументов при вызове функций многих аргументов</h3>
<p>Рассмотрим следующий код:

<r:code class="cpp">void f(shared_ptr<int>, int); // Какая-то функция, принимает разделяемый указатель и число
int g(); // Другая функция, генерирует число

void ok()
{
    shared_ptr<int> p(new int(2));
    f(p, g());
}

void bad()
{
    f(shared_ptr<int>(new int(2)), g());
}

</r:code>

Чем отличаются реализации <b>ok</b> и <b>bad</b>? Они выглядят эквивалентными. Но: <b>порядок вычисления аргументов функций не определен!</b> Это значит, что, возможно, что сначала выполнится <i>new int(2)</i>, а затем <i>g()</i>, который може выкинуть исключение. Что тогда произойдет? Конструктор <i>boost::shared_ptr</i> не будет даже вызван, и объект int(2) останется висеть в памяти. В случае многократного повторения ситуации или если объекты крпупнее чем int это може привести к значительным утечкам памяти.</p>

<h2>weak_ptr</h2>

<p>Предположим ситуацию, когда имеются два объекта ссылающиеся друг на друга, и при этом необходимо использовать для них подсчет ссылок через <b>shared_ptr</b>. Соответственно, друг на друга они тоже ссылаются через <b>shared_ptr</b>. Что произойдет в этой ситуации? После создания объекты будут ссылаться друг на друга и никогда не будут удалены! Получаем утечку памяти.</p>

<p>Как решить проблему? </p>

<p>Для таки случаев в boost был включен <b>weak_ptr</b>. Это указатель, который так же как и <i>shared_ptr</i> связан со счетчиком ссылок, однако его особенность состоит в том, что он <b>не увеличивает счетчика ссылок</b>. Т.е, если одну из связей между объектами реализовать через weak_ptr, то объекты будут корректно удалены.</p>

<p>Какая возникает проблема с <b>weak_ptr</b>? Поскольку они не увеличивают счетчика ссылок, объект может быть удален, а указатель остаться, что особенно проблемно в многопоточной среде. Поэтом, weak_ptr не действует как обычный указатель, т.е. не предоставляет возможности оперирования над объектом. Как же его использовать? </p>

<p><b>weak_ptr</b> имеет метод <b>lock()</b>, который возвращает новый <i>shared_ptr</i> на объект, и, соответственно, на время жизни этого <b>shared_ptr</b> увеличивает счетчик ссылок объекта.</p>

<p>Типичный пример использования:
<r:code class="cpp">#include <boost/shared_ptr.hpp>
#include <boost/weak_ptr.hpp>

...

boost::shared_ptr<MyObject> osptr( new MyObject() );

...

boost::weak_ptr<MyObject> owptr( osptr ); // Создаем слабый указатель на объект, на который ссылается osptr

...

// Пусть в этот момент на объект имелось n ссылок

if ( boost::shared_ptr<MyObject> po = owptr.lock() ) { // После вызова метода lock уже n+1 ссылка
	po->myMethod(); // Вызываем метод объекта
} else {
	std::cout << "Ошибка, объект уже удалили" << std::endl;
} 

// Здесь уже опять n ссылок, временный разделяемый указатель уничтожился

</r:code></p>

<h2>intrusive_ptr</h2>

<p>Последний тип умных указателей - <b>intrusive_ptr</b>. Этот тип указателя используется, когда уже имеется некоторый механизм для подсчета ссылок на объекты, и необходимо задействовать его.</p>

<p>Для того, чтобы указатель работал необходимо, чтобы были определены две функции: <b>intrusive_ptr_add_ref</b> и <b>intrusive_ptr_release</b>, принимающие в качестве аргумента указатель на объект. Определны они должны быть в пространстве имен boost, или, если компилятор поддерживает поиск пространств имен по типам аргументов, в пространстве имен используемого объекта.</p>

<p>Пример использования intrusive_ptr:

<r:code class="cpp">#include <boost/intrusive_ptr.hpp>

namespace boost {

void intrusive_ptr_add_ref( const MyObject * po ) {
	po->addRef(); // Какая-та внутренняя реализация
}

void intrusive_ptr_release( const MyObject * po ) {
	po->release(); // Внутренняя реализация освобождения объекта
}

}

...

{
	boost::intrusive_ptr<MyObject> po( new MyObject() );

	po->myField ++; // Доступ к полю объекта
	po->myMethod(); // Вызов метода объекта
	
	MyObject & robj = *po; // Получаем ссылку на хранимый объект
	MyObject * pobj = po.get(); // Получаем указатель на хранимый объект

	if ( po ) { // Проверяем, что указатель ссылается на объект
		std::cout << "Указатель ссылается на объект по адресу " << po.get() << std::endl;
	}
}

</r:code></p>

