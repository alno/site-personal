<h2>Виртуальные функции в C++</h2>

Сначала, небольшой экскурс в реализацию виртуальных функций в C++. Виртуальные функции класса позволяют переопределять их реализацию в наследниках, причем выбор конкретной реализации осуществляется динамически, в процессе выполнения программы.

Безусловно, это требует некоторой дополнительной работы со стороны компилятора. Конкретнее, объект каждого класса, имеющего виртуальные функции содержит скрытый от программиста указатель на так называемую <i>таблицу виртуальных функций</i> своего класса. В свою очередь, таблица виртуальных функций содержит указатели на конкретные реализации функций для заданного класса.

Таким, образом, понятно, что <i>вызов виртуальной функции требует <b>накладных расходов</b>, а именно: одно дополнительное обращение к памяти, для извлечения элемента таблицы виртуальных функций.</i> И тут мы напрямую подходим к утверждению о трехкратных издержках.

<h2>Корректность утверждения о трехкратных издержках</h2><a name="correctness"></a>

В предыдущем пункте, была рассмотрена реализация виртуальных функций в C++. Теперь рассмотрим две различные функции, которые могут быть виртуальными и невиртуальными. 

<ul>
<li>Во-первых, аналогично, Benoît Jacob, рассмотрим простой геттер, возвращающий int. По сути, геттер осуществляет одно обращение к памяти. Все. Разумеется, мы получаем издержки порядка двух раз, при объявлении геттера виртуальным. Benoît Jacob получил еще большее число, за счет встраивания вызова компилятором при оптимизации.</li>
<li>Теперь рассмотрим функцию класса, вычисляющую, например, определитель квадратной матрицы, что в лучшем случае выполняется за O(n*n*n) операций, где n - размерность матрицы. То есть, например, для матрицы размерности 5, это уже как минимум 125 обращений к памяти (а в действительности, больше). Соответственно <b>издержки от объявления этой функции виртуальной составляют менее 1%</b></li>
</ul>

Видно, что издержки тем меньше, чем более сложную задачу решает функция. Таким образом, <i>говорить, что виртуальные функции приводят к n-кратным издержкам, где n - любое число (3, 1.5 и т.п.) просто <b>некорректно</b>.</i> В различных задачах издержки разные.

<h2>Техника с шаблонами</h2><a name="proscons"></a>

Для устранения издержек Benoît Jacob предлагает следующую технику. Вместо кода:

<r:code class="cpp">#include <iostream>

class Animal
{
  protected:
    int age_in_years;

  public:
    Animal(int i) : age_in_years(i) {}
    virtual int actual_age() const = 0;
};

class Dog : public Animal
{
  public:
    Dog(int i) : Animal(i) {}
    virtual int actual_age() const
    {
      // one year is 7 dog-years
      return 7 * age_in_years;
    }
};

void msg(const Animal& a)
{
  std::cout << "This animal feels " << a.actual_age()
            << " years old." << std::endl;
}

int main(int, char*[])
{
  Dog d(3);
  msg(d);
  return 0;
}
</r:code>

можно написать код:

<r:code class="groovy">
#include <iostream>

template<typename Derived>
class Animal
{
  protected:
    int age_in_years;

  public:
    Animal(int i) : age_in_years(i) {}
    int actual_age() const
    {
      return static_cast<const Derived*>(this)->_actual_age();
    }
};

class Dog : public Animal<Dog>
{
    friend class Animal<Dog>;
    int _actual_age() const
    {
      // one year is 7 dog-years
      return 7 * age_in_years;
    }

  public:
    Dog(int i) : Animal<Dog>(i) {}
};

template<typename Derived>
void msg(const Animal<Derived>& a)
{
  std::cout << "This animal feels " << a.actual_age()
            << " years old." << std::endl;
}

int main(int, char*[])
{
  Dog d(3);
  msg(d);
  return 0;
}
</r:code>

Итак, какие же плюсы имеет данный подход:
<ul>
<li>Он решает свою задачу, <b>издержки исчезают</b>.</li>
</ul>
Однако, за это приходится платить некоторую цену:
<ul>
<li><b>Код усложняется</b>, становится менее читабельным, его сложнее поддерживать.</li>
<li>Функции, использующие класс Animal, приходится <b>объявлять в заголовочных файлах</b> (раздельная компиляция шаблонов пока мало распространена). В больших модулях, в заголовочные файлы уйдет много кода. Как следствие, мы получим увеличение времени сборки проекта.</li>
<li>На самом деле, <b>весь дополнительный код не нужен</b>! Например, этот код можно переписать так, ничего не потеряв:
<r:code class="groovy">#include <iostream>

class Animal
{
  protected:
    int age_in_years;

  public:
    Animal(int i) : age_in_years(i) {}
};

class Dog : public Animal
{
    int actual_age() const
    {
      // one year is 7 dog-years
      return 7 * age_in_years;
    }

  public:
    Dog(int i) : Animal(i) {}
};

template<typename Derived>
void msg(const Derived & a)
{
  std::cout << "This animal feels " << a.actual_age()
            << " years old." << std::endl;
}

int main(int, char*[])
{
  Dog d(3);
  msg(d);
  return 0;
}
</r:code>
</li>
</ul>

<h2>Заключение или как же быть с виртуальными функциями</h2><a name="conlusion"></a>

Безусловно, виртуальные функции несут издержки по производительности. Однако, это еще не повод отказываться от них совсем. Лучше следовать следующему общему правилу: <i>все средства (в частности, виртуальные функции) желательно использовать с пониманием того, что за ними стоит и к каким эффектам это приведет.</i>

В частности, к задаче оптимизации при использовании виртуальных функций:
<ul>
<li>Главное, <b>оцените свои приоритеты</b> по параметрам системы. Что Вам важнее: модифицируемость, производительность или еще что-то?</li>
<li>Помните, для любой задачи есть много решений, нужно выбрать то которое наиболее Вам подходит.</li>
<li>Рассмотрите возможность <b>перепроектирования иерархии классов</b>, с тем, чтобы использовать виртуальные функции там, где преимущества от удобства выше чем издержки.</li>
<li>Возможно, какие-то виртуальные <b>функции можно объединить</b>. Вспомните, чем меньше вызовов, тем меньше и издрежек.</li>
<li>Используйте, если это возможно, <b>общие шаблоны проектирования</b>, такие, как <a href="http://en.wikipedia.org/wiki/Strategy_pattern">Strategy</a> и <a href="http://en.wikipedia.org/wiki/Template_method_pattern">Template method</a>. Изобретение велосипеда не всегда оправдано.</li>
<li>Многие решения, в том числе вышеприведенные шаблоны можно реализовать как <b>динамически, с использованием виртуальных функций, так и статически, с использованием шаблонного метапрограммирования</b></li>
</ul>

<h2>Ссылки</h2>

<ul>
<li><a href="http://www.codeblogz.ru/2008/06/blog-post_21.html" rel="nofollow">Пост в codeblogz (Ru)</a></li>
<li><a href="http://bjacob.livejournal.com/5800.html" rel="nofollow">Benoît Jacob: Предложенная техника (En)</a></li>
<li><a href="http://bjacob.livejournal.com/6283.html" rel="nofollow">Benoît Jacob: Бенчмарки (En)</a></li>
<li><a href="http://en.wikipedia.org/wiki/Strategy_pattern" rel="nofollow">Strategy Pattern (En)</a></li>
<li><a href="http://en.wikipedia.org/wiki/Template_method_pattern" rel="nofollow">Template Method Pattern (En)</a></li>
</ul>