
Таким образом, методы могут принимать блоки кода. Например, чтобы обработать каждую строку какого-то файла в Java надо написать достаточно объемный код. В Groovy. это делается одной строкой:

<r:code class="groovy">
new File('file.txt').eachLine( { line -> println line } ) // Распечатываем каждую строку файла
</r:code>

Метод <b>eachLine</b> класса File для каждой строки файла вызвает замыкание, переданное в качестве аргумента, и передает в него содержимое строки.

В этом примере стоит обратить внимание на конструкцию <b>{ line -&gt; println line }</b> - это и есть объявление замыкания. Можно рассматривать его как функцию, которая принимает один аргумент <b>line</b> и распечатывает его.

Стоит отметить, что Groovy позволяет несколько более удобную запись, если замыкание является последним аргументом метода:
<r:code class="groovy">
new File('file.txt').eachLine() { line -> println line } // Замыкание за скобками

new File('file.txt').eachLine { line -> println line } // Или без скобок вообще
</r:code>

Чтобы объявить замыкание, принимающее несколько параметров их надо перечислить через запятую, а чтобы определить замыкание без параметров, <b>-&gt;</b> опускается. Например:
<r:code class="groovy">
def plus = { a, b -> a + b }
def do = { println "done" }
</r:code>

Как написать методы, использующие замыкания?

Пример:
<r:code class="groovy">
def forEvery3rd( list, block ) {
	def i = 0
	for ( e in list ) {
		if ( i % 3 == 0 )
			block( i )

		i ++
	}
}
</r:code>
Эта функция принимает в качестве аргумента список и замыкание, и вызывает замыкание для каждого третьего элемента списка.

<h2>Использование контекста объявления</h2>

Одной из важных особенностью замыкания является возможность использования контекста, в котором оно было объявлено, например:

<r:code class="groovy">
def str = '123'
def count = 0
new File('file.txt').eachLine { line -> if ( line == str ) count ++ }
println count
</r:code>

Этот код считает количество строк в файле, которые равны str. Причем, переменные <i>str</i> и <i>count</i>, используемые в замыкании объявлены вне его.

<h2>Возвращаемые значения</h2>

Замыкания всегда имеют возвращаемые значения. Возвращаемое значение определяется или оператором <b>return</b>, или же, если его нет, последним вычисленным выражением.

<h2>Встроенные переменные</h2>

В любых замыканиях всегда определены несколько переменных, имеющих специальный смысл:
<ul>
	<li><b>it</b> - это единственный аргумент замыкания. Использование этой переменной позволяет опускать объявление аргументов в замыкании. Например:

<r:code class="java">
def pr = { println it } // Замыкание, распечатывающее свой первый аргумент
</r:code>

	</li>
	<li><b>this</b> - это ссылка на класс, в котором объявлено замыкание</li>
	<li><b>owner</b> - это объект, содержащий контекст в котором объявлено замыкание. Значение - или this, если замыкание объявлено внутри класса или метода, или замыкание, внутри которого находится объявление замыкания.</li>
	<li><b>delegate</b> - то же самое, что и owner, однако может быть переопределено, что используется в Builders</li>
</ul>

<h2>Curring</h2>

Groovy поддерживает такую возможность, как <b>curring</b>, т.е. возможность получить новое замыкание, зафиксировав часть аргументов старого. Например:
<r:code class="groovy">
def add = { a, b -> a + b } // Замыкание - сложение двух объектов
def add1 = add.curry( 1 ) // Замыкание - сложение единицы и одного из объектов
</r:code>

<h2>Динамические объекты (Expando)</h2><a name="expando"></a>

Замыкания позволяют Groovy содержать поддержку динамических объектов, называемых Expando. Суть этих объектов в том, что они не имеют предопределенных полей и методов, однако они могут быть определены прямо в процессе выполнения:

<r:code class="groovy">
def obj = new Expando();
obj.a = 1 // Создаем новое поле
obj.b = 2 // Создаем новое поле
obj.do = { println "done" } // Добавляем новый метод к объекту
</r:code>

Стоит заметить, что добавление методов к такому объекту есть ни что иное, как создание нового замыкания и сохранение его в объекте. В принципе, динамические объекты очень похожи на maps(отображения), однако отличаются тем, что могут содержать методы.

<h2>Также на эту тему</h2>
<ul>
	<li><a href="http://blog.alno.name/2008/06/using-groovy/">Использование Groovy</a></li>
	<li><a href="http://blog.alno.name/2008/07/groovy-multimethods/">Мультиметоды в Groovy</a></li>
</ul>

<h2>Ссылки</h2>
<ul>
	<li><a href="http://groovy.codehaus.org/">Офсайт Groovy (En)</a></li>	
	<li><a href="http://groovy.codehaus.org/Closures">Groovy Closures (En)</a></li>	
	<li><a href="http://www-128.ibm.com/developerworks/library/j-pg08235/">Practically Groovy: Functional programming with curried closures (En)</a></li>
	<li><a href="http://martinfowler.com/bliki/Closure.html">Статья Мартина Фаулера о замыканиях (En)</a></li>
	<li><a href="http://voituk.kiev.ua/2008/05/12/comparator-closure-currying/">Groovy: Comparator closure & currying (Ru)</a></li>
	<li><a href="http://www.ibm.com/developerworks/ru/library/j-pg08235/index.html">Практически Groovy : Функциональное программирование с помощью использованием замыканий и карринга (Ru)</a></li>
	<li><a href="http://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">Замыкания в Википедии (Ru)</a>
</ul>
