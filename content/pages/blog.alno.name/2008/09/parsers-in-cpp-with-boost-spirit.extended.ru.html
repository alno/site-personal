<h2>Простейшие парсеры</h2>

Приведу пример, который был мною честно списан с Википедии. Это разбор строки, содержащей набор чисел через запятую в список этих чисел. Возможно, то же самое можно было бы сделать и более простыми методами, однако этот пример позволяет понять некоторые базовые принципы <b>Spirit</b>.

<r:code class="cpp">
#include <boost/spirit/core.hpp> // Основной заголовчный файл Boost::Spirit
#include <boost/spirit/actor/push_back_actor.hpp> // Конструкция push_back_a

#include <iostream>
#include <vector>
#include <string>

using namespace std;
using namespace boost::spirit; // Все типы и функции Boost::Spirit заключены в это пространство имен
 
/**
 * Функция, которая разбирает строку - список чисел через запятую в вектор этих чисел.
 * @param str строка, которую необходимо разобрать
 * @param v вектор, в который добавляются результаты
 * @return true, если разбор прошел успешно
 */
bool parse_numbers(const char* str, vector<double>& v)
{
	return parse( // Вызываем функцию boost::spirit::parse
		str, // В качестве первого аргумента передаем строку, которую необходимо разобрать
		( real_p[push_back_a(v)] >> *(',' >> real_p[push_back_a(v)]) ), // Парсер, описывающий как разбирать строку
		space_p // Грамматика, определяющая какие участки текста можно пропускать
	).full; 
	// Функция возвращает структуру boost::spirit::parse_info
	// но нас интересует только поле full - была ли строка полностью разобрана
}
</r:code>
<p>Самое интересное здесь - определения грамматик. В частности, в примере приведены две грамматики.</p>
<p>Начнем со второй, поскольку она значительно проще: <b>space_p</b> - это встроенный примитив, принимающий последовательности пробельных символов, т.е. пробелов, табов и переносов строк.</p>
<p>Перейдем к первой грамматике:</p>
<r:code class="cpp">real_p[push_back_a(v)] >> *(',' >> real_p[push_back_a(v)])</r:code>

<ul>
	<li><b>real_p</b> - парсер, который считывает из строки число с плавающей точкой.</li>
	<li>Конструкции в квадратных скобках - это <b>семантические действия</b>, которые выполняются при успешном сопоставлении парсера, к которым они привязываются. В качестве семантического действия можно указать указатель на функцию или же функтор. В качестве параметра в действие будет передано значение, возвращаемое парсером. В данном случае, это прочитанное число.</li>
	<li><b>push_back_a</b> - это встроенный функтор, определенный в заголовочном файле <i>boost/spirit/actor/push_back_actor.hpp</i>, выполняющий добавление передаваемого ему значение в указанную коллекцию. Таким образом, каждая конструкция <i>real_p[push_back_a(v)]</i> определяет парсер, считывающий число из строки и добавляющий его в вектор <i>v</i>.</li>
	<li>Оператор <b>&gt;&gt;</b> конструирует парсер, который последовательно применяет левостоящий парсер, а затем правостоящий. В частности, конструкция <b>',' &gt;&gt; real_p[push_back_a(v)]</b> обозначает считывание из строки запятой, а затем дробного числа. Стоит отметить, что левым аргументом оператора является просто символ ','. Поскольку второй аргумент - парсер, компилятор C++ способен применить его, осуществив неявное преобразование символа к парсеру, который просто считывает заданный символ из строки.</li>
	<li>Оператор <b>*</b> конструирует парсер, который осуществляет применение правостоящего парсера 0 и более раз. Т.е. конструкция <b>*(',' >> real_p[push_back_a(v)])</b></li>
</ul>

Другие парсеры можно найти в документации Spirit на страницах: <nodindex><a rel="nofollow" href="http://www.boost.org/doc/libs/1_36_0/libs/spirit/classic/doc/primitives.html">Primitives</a>, <a rel="nofollow" href="http://www.boost.org/doc/libs/1_36_0/libs/spirit/classic/doc/numerics.html">Numerics</a>, <a rel="nofollow" href="http://www.boost.org/doc/libs/1_36_0/libs/spirit/classic/doc/character_sets.html">Character Sets</a></noindex> и других.

<h2>Базовые примитивы</h2>
Как, наверное, понятно из приведенного примера, для того чтоб конструировать новые парсеры, необходим набор примитивных парсеров и операторов, которые позволяют строить более сложные парсеры. Сначала, я приведу список некоторых базовых парсеров. Сразу хочу отметить, что он далеко не полон:
<ul>
	<li><b>ch_p</b> - парсер, считывающий заданный символ. То есть, парсер считывает один символ и проверяет его на соответствие заданному. Задается он следующим образом: <b>ch_p('a')</b>. К этому парсеру автоматически преобразуются символьные константы, которые встречаются в опеределении грамматики.</li>
	<li><b>str_p</b> - аналогично, только считывает и проверяет не один символ, а непрерывную последовательность. Например: <b>str_p("abcd")</b>. К нему преобразуются строковые константы в определении грамматики.</li>
	<li><b>chseq_p</b> - очень похож на предыдущий, также считывает последовательность символов, заданную в строке-параметре. Отличие: символы в последовательности могут быть разделены пробельными, т.е. теми, которые принимаются парсером, обозначающим какие участки можно пропускать. Т.е. chseq_p("abc") успешно примет "a bc", тогда как str_p("abc") не примет.</li>
	<li><b>anychar_p, alnum_p, alpha_p, digit_p, lower_p, upper_p</b> - парсеры, которые принимают любой символ, букву или цифру, букву, цифру, символ в нижнем регистре и символ в верхнем регистре соответственно.</li>
	<li><b>uint_p, bin_p, oct_p, hex_p</b> - парсеры, считывающие беззнаковое целое число в десятичной, двоичной, восьмеричной и шестнадцатиричной системе счисления соответственно.</li>
	<li><b>int_p</b> - парсер, считывающий целое число в десятичной системе, возможно со знаком.</li>
	<li><b>real_p,ureal_p</b> - парсеры, считывающие знаковое и беззнаковое числа с плавающей точкой соответственно.</li>
</ul>

<h2>Операторы</h2>
Опять же, неполный список операторов:
<ul>
	<li><b>a &gt;&gt; b</b> - оператор последовательного применения. Создает парсер,получаемый последовательным применением аргументов.</li>
	<li><b>a | b</b> - альтернатива. Создает парсер, который пытается по очереди применить аргументы для того, чтобы разобрать строку, пока какой-либо не выдаст положительный результат.</li>
	<li><b>a &amp; b </b> - пересечение. Парсер, который применяется успешно тогда, когда оба аргумента успешно разбирают строку.</li>
	<li><b>a - b</b> - разность. Получаемый парсер принимает строку тогда, когда первый аргумент ее принимает, а второй нет.</li>
	<li><b>~ a</b> - парсер который принимает все, что не принимает аргумент.</li>
	<li><b>* a</b> - повторение аргумента 0 и более раз.</li>
	<li><b>+ a</b> - повторение аргумента 1 и более раз.</li>
	<li><b>! a</b> - опционально применение аргумента, т.е. его повторение 0 или 1 раз.</li>
	<li><b>a % b</b> - оператор списка. Эквивалентен <b>a &gt;&gt; * ( b &gt;&gt; a )</b>. То есть создает парсер, осуществляющий разбор непустого списка, где первый аргумент - элемент списка и второй аргемент - разделитель.</li>
</ul>

Другие операторы можно найти в документации Spirit на странице: <nodindex><a rel="nofollow" href="http://www.boost.org/doc/libs/1_36_0/libs/spirit/classic/doc/operators.html">Operators</a></noindex>

<h2>Еще один пример</h2>
Для того, чтобы понять как все это работает, рассмотрим еще один пример. Предположим, мы хотим распарсить набор "свойство-значение", где имя состоит из букв и цифр, а значение свойства - произвольная строка в двойных кавычках. Элементы карты разделены запятой, ключ и значение разделено двоеточием.
Будем строить грамматику сверху вниз:
<ul>
	<li>На самый общий взгляд наш текст представляет из себя список некоторых элементов, разделенных запятой. Так и запишем:<pre lang="cpp">/*элемент*/ % ','</pre></li>
	<li>Что представляет из себя элемент? Это пара ключ-значение, разделенные двоеточием. Добавим это вместо <b>/*элемент*/</b> <pre lang="cpp">( /*ключ*/ >> ':' >> /*значение*/ ) % ','</pre></li>
	<li>Что есть ключ? Непустая последовательность букв и цифр, без разделителей. Для того, чтобы показать, что какой-то участок текста не должен содержать разделителей используется директива <b>lexeme_d</b>. Тогда, парсер примет вид: <pre lang="cpp">( lexeme_d[ +alnum_p ] >> ':' >> /*значение*/ ) % ','</pre></li>
	<li>Значение это произвольная строка без кавычек, заключенная в кавычки. И все это без разделителей. Итоговый парсер принимает вид: <pre lang="cpp">( lexeme_d[ +alnum_p ] >> ':' >> lexeme_d[ '"' >> +~ch_p('"') >> '"' ] ) % ','</pre></li>
</ul>

Теперь, необходимо как-то добавлять ключ и значение в std::map. Для этого будем использовать следующий подход: при считывании ключа сохраняем его в локальную переменную, а при считывании значения добавляем пару в std::map. Для этого необходимо использовать два встроенных функтора: <b>assign_a</b> и <b>insert_at_a</b> - которые сохраняют значение в переменную и вставляют элемент в контейнер соответственно.

Другие встроенные функторы можно найти в документации Spirit на странице: <nodindex><a rel="nofollow" href="http://www.boost.org/doc/libs/1_36_0/libs/spirit/classic/doc/predefined_actors.html">Predefined Actors</a></noindex>

Полный текст примера примет вид:
<r:code class="cpp">
#include <string>
#include <map>

#include <boost/spirit/core.hpp>
#include <boost/spirit/actor/assign_actor.hpp>
#include <boost/spirit/actor/insert_at_actor.hpp>

using namespace boost::spirit;

bool parseConfig( const char * str, std::map<std::string,std::string> & mp ) {
	std::string key;
	
	return parse(
		str,
		( ( lexeme_d[+alnum_p][assign_a(key)] >> ':' >> lexeme_d[ '"' >> ( *~ch_p('"') )[insert_at_a(mp,key)] >> '"' ] ) % ',' ),
		space_p
	).full;
}
</r:code>

Далее: <a href="http://blog.alno.name/2008/12/advanced-boost-spirit/">Boost::Spirit: Грамматики, функции и замыкания</a>
